#Extracting More Concurrency from Distributed Transaction
##Abstract
-	Distributed Transaction：

	>	A distributed transaction is a transaction that updates data on two or more networked computer systems. Distributed transactions extend the benefits of transactions to applications that must update distributed data.
	
	-	就是指在分布式系统上的每一项交易都必须在所有的分布式节点上进行更新。
	- 	而为了保证这一点，其中的最大的难处就是保证交易的原子性，也就是说如果交易成功，则该值必须在所有的节点服务器上进行更新，若失败就需要在所有的节点上进行回流。不能出现只在一台服务器更新，其他不更新的情况。
	
-	处理分布式的交易的传统方式都是基于2PL(two-phase lock)和OCC(optimistic concurrency control)。
-	当交易互相冲突，2PL会将这俩个交易串行化。而OCC则使用中断去解决他们。
- 	Rococo是一种处理交易的新协议，他将交易当作原子操作集合。服务器集群首先将同时发生的交易收集起来，获取他们的依赖关系，但是先不处理他们，然后在约定的时间，将交易的依赖关系分发给所有的节点，重排交易次序，然后用串行顺序处理。
-  Rococo的性能在工作负载较高的情况下比其他两个好，使用scaled TPC-C benchmark进行测试。

##Introduction
-	举例说明了交易中的冲突现象（OLTP交易系统）。

- 	2PL和OCC在工作负荷较大情况下，处理交易冲突的性能会显著下降。当遇到大量的交易冲突事务时，2PL和OCC会不断中断和重试这些任务，导致吞吐量降低、潜伏时间提高。
-  在Rococo中，不用大量的中止、阻塞交易，使用下列俩种关键技术就能实现安全的交叉存取。
	-	使用依赖性跟踪，延缓并重排交易处理。
	- 	基于__碎片化交易理论__的离线安全检查。
-	Rococo是一个处理原子事务级别的双周期协议。服务器端可以获取数据，而中间机群则代表客户端运行着协议。第一个周期就是将事务分派给合适的服务器，然后在每一个服务器上建立临时的处理事务的顺序。而服务器会等到第二个周期才开始处理事务，所以在这之前次序可以不断的改变
- 第一个过程中，服务器通过向中间件提供依赖信息，从而告诉中间件不同交易的冲突事件的顺序。
- 中间件集合依赖信息，然后将信息分发给服务器，服务器去使用这些依赖信息去识别在第一个周期中，这些同时到达的交易事务是否可以串行化，如果可以就将他们放在第二个周期进行，如果不可以就确立处理他们的顺序，然后进行处理。这俩种情况，Rococo都可以避免中断，同时处理交易。
- 一般情况下，依赖关系只在服务器和中间件之间进行交换，但是当冲突交易不断被覆盖，Rococo则会适当的要求服务器与服务器之间的连接，以确保一个确定的顺序。
- 	并非所有的交易事务都会被延缓到第二个周期才开始处理，有一些必须在第一个周期中马上得到处理，因为他们是不可串行化的任务交错。
-  为了在运行的时候，确保一个可以被严格串行的次序，Rococo会在开始交易之前开始离线检查。离线检查识别并分类潜在的冲突，如果一个冲突事务被发现不能被重排（不安全的交错），Rococo就会把这些事务合并成为一个原子操作。虽然传统的并发控制协议被用来自动地在服务器之间执行合并的部分，但ROCOCO协议用于在事务中执行多个合并的部分。
-  使用scaled TPC-C benchmark去评价性能。

#Overview
-	在这里较为详细的比较了传统的防止中断的方式以及Rococo重排冲突方式。

##传统：
-	2PL和OCC在许多冲突交易中在竞争性工作负载的表现不佳。

-	虽然在每一个服务器上，每一项服务都能被作为原子操作去处理，但是需要分布式并发控制来防止跨服务器的非序列化片段交叉。

-	OCC只要在执行非序列化交叉片段时，有另一个任务插入就会被打断，最后俩个任务都失效。
-	2PL比OCC好点，2PL在每一个数据访问时都会加锁。除了阻塞冲突进程之外，2PL也会通过中断去防止死锁发生。但是一些比较高效的死锁防止机制会导致经常在没有死锁的时候，产生中断。

##ROCOCO：
-	明确interference：T1在执行的时候，T2插入，这就造成了干扰。

- 	ROCOCO利用在服务器上发生冲突时产生的事务之间的依赖关系信息来跟踪潜在的干扰
-  服务器使用依赖关系信息来检测交易之间是否干扰并确定性地重新排列事务，以便它们在所有涉及的服务器上以相同的顺序执行，因此不再发生干扰。
-  ROCOCO可以改变事物顺序，因为它采用双周期消息来提交他们。
-  第一轮开始时，代表客户运行的事务协调员将一个事务片段传播给相应的服务器。服务器尚未执行这些部分，而是将相关性信息返回给协调员以完成第一轮。然后，协调员将所有依赖信息合并，并将其分发到第二轮中的所有服务器。
-  如果有必要，服务器会在执行它们之前重新排列事务的部分。
-  通过对干扰事务进行重新排序而不是中止事务，ROCOCO可以在存在不少琐碎的争用时实现显着的性能提升，而OLTP工作负载往往是这种情况

#Design
-	Rococo的实现包括两个部分，包括offline checker和runtime protocol，offline checker确定是否可以在运行时正确地重新安排事务集合的各个部分，运行时协议则跟踪片段之间的依赖关系，并在必要的时候重新排序他们的执行次序来确保正确性。
##Checking When Reordering is Viable
-	先说明immediate时间和deferrable事件的区别
- 	接着讲述offline checker是如何确定是否可以在运行时正确地重排序。使用S-C图。
	-	每个事务在图中以两个实例出现，每个块都是顶点，并且来自同一事务实例的块通过S边连接	
	-	如果两个部分访问同一个数据库表并且至少有一个访问是写入，则它们通过C（冲突）边对接。
	- 	如果图中的一个周期同时包含S和C边，则它是一个SC周期。每个SC周期发出一个可能导致不可序列化执行的潜在冲突
-	检查器通过将C片边缘的任何片段的标签更改为I片段，直接在C片边缘传播immediacy，直到在具有不同I / D标签的片段之间没有C边缘。我们不会得到I-D边缘
- 	__最后，检查器检查是否存在所有C边都是I-I边的不可修复的SC循环。__如果没有，ROCOCO的基本协议可以安全地对所有冲突进行重新排序，以确保在运行时可串行化。对于具有所有I-I C边缘的不可编译SC循环，检查器建议将属于同一事务的循环中的那些片段合并为更大的原子片段.这部分依赖传统的分布式并非控制方法来执行。

##basic protocol
-	运行时协议执行一系列事务，这些事务通过offline checker被认为是可以重排的。
-	coordinator会收到客户的交易请求，将分为两个阶段处理交易。开始和提交。
	-	在开始阶段，coordinator将片段发送到服务器并收集返回的依赖关系。
	- 在提交阶段，coordinator将聚集的依赖信息传播给所有参与处理的服务器，他们会确定一个可串行化的订单并处理冲突事务。
-	开始阶段中，coordinator分发事务给服务器，为他们设置一个临时命令，执行即时片段并收集依赖信息。
	-	服务器看到立即事务的时候会马上处理.
	- 	服务器收到可延迟的事件，就会将其缓存以供稍后执行。
	-  服务器除了执行即时事件以及缓存可延迟时间之外，还维护一个依赖关系图dep。在这个图中，每一个顶点代表其事务以及其已知状态，服务器回去维护俩个顶点之间的依赖关系以及他们自身的状态。
	-	服务器会将依赖关系图发送到coordinator，最后去整合这个依赖关系图。
-	在提交阶段，coordinator为所有的事务分配依赖关系，确保每一个服务器都能够拥有安全的决定是否必须重新排序事件、确定地重排所有事件、执行延期交易的机会。
- 	在最后阶段中，服务器会处理在交易T的强连通集中的所有事件，并将结果返回给coordinator
- 	当coordinator收集到所有来自服务器的回应之后，交易提交然后结果返回给客户端。

##证明正确性
-	这一部分主要讲述的是ROCOCO协议对强串行性的保证。
- 	一些定义：
	-	Serializability：所有提交的交易都有等价的串行序列，以保证所有发生冲突的事件都会有他所等价的串行序列。
	- 